/*!
 * jQuery.formWhen.js
 * sertion@innorix.com
 * https://github.com/skt-t1-byungi/jQuery.formWhen
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jQuery"));
	else if(typeof define === 'function' && define.amd)
		define(["jQuery"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("jQuery")) : factory(root["jQuery"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(1);
	__webpack_require__(2);

	var Case = __webpack_require__(3);
	__webpack_require__(7);
	__webpack_require__(8);


	$.fn.formWhen = function(defineFunction) {
	    if (!$.isFunction(defineFunction)) {
	        throw new Error('invalid define!');
	    }

	    if (this.length === 0) {
	        return this;
	    }

	    var fieldHelper = (function(name) {
	        return $.field(this, name);
	    }).bind(this);

	    var when = function(condition) {
	        return new Case(this, fieldHelper, condition);
	    };

	    defineFunction(when.bind(this), fieldHelper);

	    return this;
	};

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ },
/* 2 */
/***/ function(module, exports) {

	/**
	  (The MIT License)

	  Copyright (c) 2012 Gilles Ruppert <gilles@madeofbytes.com>

	  Permission is hereby granted, free of charge, to any person obtaining
	  a copy of this software and associated documentation files (the
	  'Software'), to deal in the Software without restriction, including
	  without limitation the rights to use, copy, modify, merge, publish,
	  distribute, sublicense, and/or sell copies of the Software, and to
	  permit persons to whom the Software is furnished to do so, subject to
	  the following conditions:

	  The above copyright notice and this permission notice shall be
	  included in all copies or substantial portions of the Software.

	  THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
	  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


	  serialises a form to an object. The use is the same than $.fn.serialize
	  and $.fn.serializeArray.
	  The keys are the form element names and the value is the the form element
	  value. If multiple form elements have the same name with different values,
	  the value is an array with all the values. `undefined` and `null` are
	  converted to empty strings.
	 */

	jQuery.fn.serializeObject = function() {
	  var o = {};
	  var a = this.serializeArray();
	  for (var i = 0, l = a.length; i < l; i++) {
	    var item = a[i];
	    var name = item.name;
	    // if the value is null or undefined, we set to empty string, else we
	    // use the value passed
	    var value = item.value != null ? item.value : '';

	    // if the key already exists we convert it to an array
	    if (o[name] !== undefined) {
	      if (!o[name].push) {
	        // convert to array
	        o[name] = [o[name]];
	      }
	      o[name].push(value);
	    }
	    else {
	      o[name] = value ;
	    }
	  }

	  return o;
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(1);
	var equal = __webpack_require__(4);

	function attachHandler($form, caseObj) {
	    $form.on("formWhen", function(event, valueObj) {

	        if (caseObj.conditionCheck(valueObj)) {
	            if (!caseObj.lastState) {
	                caseObj.lastState = true;
	                caseObj.trueHandlers.fireWith($form, [caseObj.fieldHelper, valueObj]);
	            }
	        } else {
	            if (caseObj.lastState) {
	                caseObj.lastState = false;
	                caseObj.falseHandlers.fireWith($form, [caseObj.fieldHelper, valueObj]);
	            }
	        }
	    });
	}

	var Case = function($form, fieldHelper, condition) {
	    this.$form = $form;
	    this.condition = condition;
	    this.lastState = null;
	    this.trueHandlers = $.Callbacks();
	    this.falseHandlers = $.Callbacks();
	    this.fieldHelper = fieldHelper;

	    attachHandler($form, this);
	};

	Case.prototype = {
	    then: function(trueHandler, falseHandler) {
	        if ($.isFunction(trueHandler)) {
	            this.trueHandlers.add(trueHandler);
	        }

	        if ($.isFunction(falseHandler)) {
	            this.falseHandlers.add(falseHandler);
	        }
	        return this;
	    },

	    conditionCheck: function(valueObj, condition) {
	        condition = condition || this.condition;

	        if ($.isFunction(condition)) {
	            return condition.call(this.$form, valueObj);
	        }

	        //or
	        if ($.isArray(condition)) {
	            for (var i = condition.length - 1; i >= 0; i--) {
	                if (this.conditionCheck(valueObj, condition[i])) {
	                    return true;
	                }
	            }
	            return false;
	        }

	        //and
	        if ($.isPlainObject(condition)) {
	            for (var k in condition) {
	                if (!equal(condition[k], valueObj[k])) {
	                    return false;
	                }
	            }
	            return true;
	        }
	        return this.condition;
	    },
	};

	module.exports = Case;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var pSlice = Array.prototype.slice;
	var objectKeys = __webpack_require__(5);
	var isArguments = __webpack_require__(6);

	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;

	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();

	  // 7.3. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
	    return opts.strict ? actual === expected : actual == expected;

	  // 7.4. For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	}

	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}

	function isBuffer (x) {
	  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}

	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = objectKeys(a),
	        kb = objectKeys(b);
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return typeof a === typeof b;
	}


/***/ },
/* 5 */
/***/ function(module, exports) {

	exports = module.exports = typeof Object.keys === 'function'
	  ? Object.keys : shim;

	exports.shim = shim;
	function shim (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}


/***/ },
/* 6 */
/***/ function(module, exports) {

	var supportsArgumentsClass = (function(){
	  return Object.prototype.toString.call(arguments)
	})() == '[object Arguments]';

	exports = module.exports = supportsArgumentsClass ? supported : unsupported;

	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	};

	exports.unsupported = unsupported;
	function unsupported(object){
	  return object &&
	    typeof object == 'object' &&
	    typeof object.length == 'number' &&
	    Object.prototype.hasOwnProperty.call(object, 'callee') &&
	    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
	    false;
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(1);

	$.field = function(elem, name) {
	    var $form = elem.jquery ? elem : $(elem),
	        $inputs = $form.find(':input[name]').not(':button');

	    if (!name) {
	        return $inputs;
	    }

	    switch ($.type(name)) {
	        case 'string':
	        case 'number':
	            return $inputs.filter('[name=' + name + ']');

	        case 'array':
	            if (name.length === 0) {
	                break;
	            }

	            var $set = $();
	            for (var i = name.length - 1; i >= 0; i--) {
	                $set = $set.add($.field(elem, name[i]));
	            }

	            return $set;

	        case 'function':
	            return $.field(elem, name());

	        case 'regexp':
	            return $inputs.filter(function() {
	                return name.test($(this).attr('name'));
	            });
	    }

	    return null;
	};

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(1);
	var equal = __webpack_require__(4);
	var debounce = __webpack_require__(9);

	var trigger = function(event) {
	    var $form = $(event.delegateTarget),
	        old = $form.data('_formWhenOld'),
	        current = $form.serializeObject();

	    if (!equal(old, current)) {
	        $form.data('_formWhenOld', current); //save old data
	        $form.trigger('formWhen', [current]);
	    }
	}

	$.event.special.formWhen = {
	    setup: function() {
	        var $form = $(this);
	        $form.on('change.formWhen', '[name]:not(:text, textarea)', trigger);
	        $form.on('input.formWhen', '[name]:text, [name]textarea', debounce(trigger, 200));
	    },

	    teardown: function() {
	        $(this).off('.formWhen');
	    },
	};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */

	var now = __webpack_require__(10);

	/**
	 * Returns a function, that, as long as it continues to be invoked, will not
	 * be triggered. The function will be called after it stops being called for
	 * N milliseconds. If `immediate` is passed, trigger the function on the
	 * leading edge, instead of the trailing.
	 *
	 * @source underscore.js
	 * @see http://unscriptable.com/2009/03/20/debouncing-javascript-methods/
	 * @param {Function} function to wrap
	 * @param {Number} timeout in ms (`100`)
	 * @param {Boolean} whether to execute at the beginning (`false`)
	 * @api public
	 */

	module.exports = function debounce(func, wait, immediate){
	  var timeout, args, context, timestamp, result;
	  if (null == wait) wait = 100;

	  function later() {
	    var last = now() - timestamp;

	    if (last < wait && last > 0) {
	      timeout = setTimeout(later, wait - last);
	    } else {
	      timeout = null;
	      if (!immediate) {
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      }
	    }
	  };

	  return function debounced() {
	    context = this;
	    args = arguments;
	    timestamp = now();
	    var callNow = immediate && !timeout;
	    if (!timeout) timeout = setTimeout(later, wait);
	    if (callNow) {
	      result = func.apply(context, args);
	      context = args = null;
	    }

	    return result;
	  };
	};


/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = Date.now || now

	function now() {
	    return new Date().getTime()
	}


/***/ }
/******/ ])
});
;